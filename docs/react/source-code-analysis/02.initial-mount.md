# react å†…éƒ¨çš„åˆå§‹åŒ–æŒ‚è½½

ç°åœ¨ä¸‹é¢æœ‰å¦‚ä¸‹é¡µé¢æ¸²æŸ“ä»£ç ï¼š

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>React in HTML</title>
    <script src="./react.development.js"></script>
    <script src="./react-dom.development.js"></script>
    <script
      crossorigin
      src="https://unpkg.com/@babel/standalone/babel.min.js"
    ></script>
  </head>
  <style>
    .component {
      border: 1px solid #ccc;
      padding: 10px;
      margin: 10px;
    }
  </style>
  <body>
    <div id="root"></div>

    <!-- ä½¿ç”¨ type="text/babel" è®© Babel ç¼–è¯‘ JSX -->
    <script type="text/babel">
      function A() {
        return (
          <div className="component" data-name="A">
            <div>A</div>
            <div>B</div>
          </div>
        );
      }

      // åˆ›å»º React ç»„ä»¶
      function App() {
        return <A />;
      }

      // æ¸²æŸ“ç»„ä»¶åˆ° DOM
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
```

## Fiber ç»“æ„ä»‹ç»

ä¸Šé¢çš„ä»£ç å¤§æ¦‚æ˜¯å¦‚ä¸‹çš„å±‚çº§ç»“æ„ï¼š

```jsx
<App>
  <A>
    <div>
      <div>A</div>
      <div>B</div>
    </div>
  </A>
</App>
```

ä¸Šé¢çš„ç»“æ„åœ¨`React`ä¸­ä¼šæ„å»ºå¦‚ä¸‹å›¾çš„ä¸€ä¸ª`FiberTree`
![alt text](./images/image-2.png)

ä»ä¸Šå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œåœ¨è¯¥`FiberTree`ä¸­ä¸€å…±åŒ…å« 2 ç§ä¸åŒçš„ç±»å‹ï¼š

- `FiberRootNode`: `FiberRootNode` æ˜¯ä¸€ä¸ªç‰¹æ®ŠèŠ‚ç‚¹ï¼Œå……å½“ `React` çš„æ ¹èŠ‚ç‚¹ï¼Œå®ƒä¿å­˜ç€æ•´ä¸ªåº”ç”¨ç¨‹åºæ‰€éœ€çš„å…ƒæ•°æ®ã€‚å…¶ `current` å±æ€§æŒ‡å‘å®é™…çš„ `Fiber` æ ‘ç»“æ„ï¼Œæ¯æ¬¡æ„å»ºæ–°çš„ `Fiber` æ ‘æ—¶ï¼Œå®ƒéƒ½ä¼šå°† `current` é‡æ–°æŒ‡å‘æ–°çš„ `HostRoot`ã€‚
- `FiberNode`: `react`å†…éƒ¨ä¸­å¯¹ç»“ç‚¹çš„ä¸€ç§è¡¨ç¤ºï¼ŒåŒ…å«å¾ˆå¤šå±æ€§å¯ä»¥å¯¹å…¶ç»“ç‚¹è¿›è¡Œæè¿°
  - `tag`: `FiberNode`æœ‰è®¸å¤šä¸åŒçš„å­ç±»å‹ï¼Œåœ¨`render`ä»¥åŠ`commit`é˜¶æ®µä¼šæ ¹æ®è¯¥å€¼è¿›è¡Œä¸åŒçš„å¤„ç†ï¼Œå¦‚`HostRoot`ã€`FunctionComponent`ã€`ClassComponent`ã€`HostComponent`ç­‰ç­‰
  - `stateNode`: å¯¹äº`tag`ä¸º`HostComponet`çš„`FiberNode`ï¼Œå…¶æŒ‡å‘é¡µé¢ä¸­å®é™…æ¸²æŸ“çš„`DOM`èŠ‚ç‚¹
  - `child`ã€`sibling`ã€`return`: åˆ†åˆ«æŒ‡å‘å­èŠ‚ç‚¹ï¼Œå…„å¼ŸèŠ‚ç‚¹ä»¥åŠçˆ¶èŠ‚ç‚¹ï¼Œç”¨äºæ„é€ å®Œæ•´`Fiber`æ ‘
  - `flags`: ç”¨äºè¡¨ç¤ºåœ¨ `commit` é˜¶æ®µéœ€è¦æ›´æ–°çš„ç±»å‹ã€‚subtreeFlags è¡¨ç¤ºå…¶å­æ ‘éœ€è¦æ›´æ–°çš„ç±»å‹

ä¸Šé¢å¯¹äº`FiberNode`çš„å±æ€§ä»‹ç»åªåŒ…å«å½“å‰åˆå§‹åŒ–é¡µé¢æ‰€éœ€è¦çš„å±æ€§ï¼Œå…¶ä»–å±æ€§åœ¨åé¢éœ€è¦ç”¨åˆ°æ—¶å†è¿›è¡Œè§£é‡Šã€‚

## å¤§è‡´è¿‡ç¨‹

æˆ‘ä»¬å…ˆæ¥æŠŠæ•´ä¸ªæ¸²æŸ“è¿‡ç¨‹è¿›è¡Œä¸€ä¸ªç²—ç•¥çš„ä»‹ç»ï¼Œæˆ‘ä»¬åœ¨æ¸²æŸ“é¡µé¢æ—¶ï¼Œä¼šæ‰§è¡Œä¸‹é¢çš„ä»£ç 

```jsx
const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œåˆ†ä¸ºäº†ä»¥ä¸‹ä¸¤ä¸ªä¸»è¦è¿‡ç¨‹ï¼š

1. `createRoot`
2. `render`

### `createRoot`

ä¸Šé¢çš„`createRoot`ä¼šåˆ›å»ºä¸€ä¸ª`FiberRootNode`

```jsx
function createRoot(container, options) {
  var root = createContainer(
    container,
    ConcurrentRoot,
    null,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
  );
  return new ReactDOMRoot(root);
}

function createContainer(
  containerInfo,
  tag,
  hydrationCallbacks,
  isStrictMode,
  concurrentUpdatesByDefaultOverride,
  identifierPrefix,
  onRecoverableError,
  transitionCallbacks,
) {
  var hydrate = false;
  var initialChildren = null;
  return createFiberRoot(
    containerInfo,
    tag,
    hydrate,
    initialChildren,
    hydrationCallbacks,
    isStrictMode,
    concurrentUpdatesByDefaultOverride,
    identifierPrefix,
    onRecoverableError,
  );
}

function createFiberRoot(
  containerInfo,
  tag,
  hydrate,
  initialChildren,
  hydrationCallbacks,
  isStrictMode,
  concurrentUpdatesByDefaultOverride,
  identifierPrefix,
  onRecoverableError,
  transitionCallbacks,
) {
  var root = new FiberRootNode(
    containerInfo,
    tag,
    hydrate,
    identifierPrefix,
    onRecoverableError,
  );
  var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;
  return root;
}
```

ä¸Šé¢ä»£ç çš„å¤§è‡´æ‰§è¡Œæµç¨‹å¦‚ä¸‹ï¼š
![alt text](./images/image-13.png)

æ‰§è¡Œå®Œæˆåï¼Œä¼šåˆ›å»ºä¸€ä¸ª`FiberRootNode`ï¼Œä¿å­˜åœ¨`ReactDomRoot`å®ä¾‹çš„`this._internalRoot`ä¸­ï¼Œå……å½“ `React` çš„æ ¹èŠ‚ç‚¹ï¼Œå®ƒä¿å­˜ç€æ•´ä¸ªåº”ç”¨ç¨‹åºæ‰€éœ€çš„å…ƒæ•°æ®ã€‚å…¶ `current` å±æ€§æŒ‡å‘å®é™…çš„ `Fiber` æ ‘ç»“æ„ï¼Œæ¯æ¬¡æ„å»ºæ–°çš„ `Fiber` æ ‘æ—¶ï¼Œå®ƒéƒ½ä¼šå°† `current` é‡æ–°æŒ‡å‘æ–°çš„ `HostRoot`ã€‚ç”Ÿæˆå¦‚ä¸‹`FiberTree`ç»“æ„ï¼š
![alt text](./images/image-8.png)

å½“å‰çš„`root`å±æ€§å¦‚ä¸‹ï¼š

![alt text](./images/image-4.png)

ä¸Šå›¾ä¸­çš„`root`ä¸ºå½“å‰`ReactDOMRoot`çš„å®ä¾‹ï¼Œå†…éƒ¨`_internalRoot`ä¸ºå½“å‰å®ä¾‹çš„`FiberRootNode`ï¼Œå…¶`current`æŒ‡å‘å½“å‰é¡µé¢çš„`FiberNode`èŠ‚ç‚¹ã€‚å…¶ä¸­`tag`çš„å€¼ä¸º`3`ï¼Œè¡¨ç¤º`FiberNode`çš„èŠ‚ç‚¹ç±»å‹ä¸º`HostRoot`ã€‚

![alt text](./images/image-5.png)

### render

åœ¨`render`è¿‡ç¨‹ä¸­ä¸»è¦æ‰§è¡Œäº†ä¸‹é¢å†…å®¹ï¼š

```jsx
ReactDOMRoot.prototype.render = function (children) {
  var root = this._internalRoot;
  updateContainer(children, root, null, null);
};

function updateContainer(element, container, parentComponent, callback) {
  // some other code...
  var update = createUpdate(eventTime, lane);
  update.payload = {
    element: element,
  };
  callback = callback === undefined ? null : callback;
  var root = enqueueUpdate(current$1, update, lane);

  if (root !== null) {
    // è¿›å…¥è°ƒåº¦å™¨ schedule
    scheduleUpdateOnFiber(root, current$1, lane, eventTime);
  }
  return lane;
}

function scheduleUpdateOnFiber(root, fiber, lane, eventTime) {
  if (
    (executionContext & RenderContext) !== NoLanes &&
    root === workInProgressRoot
  ) {
    // some code...
  } else {
    // ç¡®ä¿FiberRootNodeè¢«è°ƒåº¦
    ensureRootIsScheduled(root, eventTime);
  }
}

function ensureRootIsScheduled(root, currentTime) {
  // some code...
  // è·å–æ›´æ–°ä¼˜å…ˆçº§ï¼Œæ‹¿å–æœ€é«˜çº§åˆ«çš„ä¼˜å…ˆçº§ä»»åŠ¡è¿›è¡Œæ‰§è¡Œ
  scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));
}

function performSyncWorkOnRoot(root) {
  var exitStatus = renderRootSync(root, lanes);
  var finishedWork = root.current.alternate;
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  commitRoot(
    root,
    workInProgressRootRecoverableErrors,
    workInProgressTransitions,
  );
  return null;
}
```

ä¸Šé¢çš„ä»£ç å¯ä»¥æ¦‚æ‹¬ä¸ºä¸‹é¢çš„æµç¨‹å›¾ï¼š
![alt text](./images/image-6.png)

å…¶ä¸­`scheduleUpdateOnFiber`ã€`ensureRootIsScheduled`ä»¥åŠ`scheduleSyncCallback`éƒ½æ˜¯è°ƒåº¦ç›¸å…³çš„å‡½æ•°ï¼Œæœ¬ç« çš„é‡ç‚¹æ˜¯æ¸²æŸ“ï¼Œå…ˆæš‚æ—¶è·³è¿‡è¿™äº›å†…å®¹ï¼ŒåæœŸè°ƒåº¦ç›¸å…³ä¼šè¯¦ç»†è®²è§£ã€‚æ¸²æŸ“ç›¸å…³çš„æ ¸å¿ƒå‡½æ•°ä¸º`performSyncWorkOnRoot`ï¼Œä»¥åŠ`performConcurrentWorkOnRoot`å‡½æ•°ï¼Œ`performSyncWorkOnRoot`ä¸º**åŒæ­¥æ¨¡å¼**ï¼Œ`performConcurrentWorkOnRoot`ä¸º**å¹¶å‘æ¨¡å¼**

#### åŒæ­¥æ¨¡å¼

```text
performSyncWorkOnRoot
    â†“
renderRootSync  // åŒæ­¥æ¸²æŸ“æ ¹èŠ‚ç‚¹
    â†“
workLoopSync    // åŒæ­¥å·¥ä½œå¾ªç¯ï¼ˆä¸å¯ä¸­æ–­ï¼‰
    â†“
completeUnitWork // å®Œæˆå•å…ƒå·¥ä½œ
    â†“
commitRoot      // æäº¤å˜æ›´åˆ°DOM
```

#### å¹¶å‘æ¨¡å¼

```text
performConcurrentWorkOnRoot
    â†“
renderRootConcurrent  // å¹¶å‘æ¸²æŸ“æ ¹èŠ‚ç‚¹
    â†“
workLoopConcurrent    // å¹¶å‘å·¥ä½œå¾ªç¯ï¼ˆå¯ä¸­æ–­ï¼‰
    â†“
shouldYield? â†’ æ˜¯ â†’ æš‚åœå¹¶è¿”å›
    â†“
completeUnitWork
    â†“
commitRoot
```

ä¸Šé¢çš„åŒæ­¥æ¨¡å¼ä¸å¹¶å‘æ¨¡å¼çš„ä¸»è¦åŒºåˆ«ä¸ºæ¸²æŸ“æ ¹èŠ‚ç‚¹çš„è¿‡ç¨‹ï¼Œ**åŒæ­¥æ¨¡å¼**åˆ›å»º`FiberTree`çš„è¿‡ç¨‹**ä¸å¯ä¸­æ–­**ï¼Œ**å¹¶å‘æ¨¡å¼**åˆ™å¯ä»¥è¢«**é«˜ä¼˜å…ˆçº§ä»»åŠ¡ä¸­æ–­**ï¼Œè€Œ`commitRoot`è¿‡ç¨‹åˆ™æ˜¯ä¸€è‡´çš„ï¼Œéƒ½æ˜¯åŒæ­¥æ‰§è¡Œã€‚

ä¸Šé¢ä»£ç å¯ä»¥çœ‹åˆ°`render`å‡½æ•°ä¸­æ‰§è¡Œäº†`renderRootSync`ä¸`commitRoot`ä¸¤ä¸ªå‡½æ•°ï¼Œä¹Ÿæ˜¯`React`ä¸­æ¯”è¾ƒé‡è¦çš„ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯åˆ›å»º`FiberNode`ä»¥åŠå¯¹åº”çš„`stateNode`ã€`flags`ã€`subtreeFlags`,å¹¶ç”Ÿæˆ`FiberTree`ï¼Œå¦ä¸€ä¸ªæ˜¯æ ¹æ®å‰é¢åˆ›å»ºçš„`FiberTree`ï¼Œè·å–å¯¹åº”èŠ‚ç‚¹çš„`flags`ä»¥åŠ`subtreeFlags`æ¥è¿›è¡Œå¯¹åº”çš„`DOM`èŠ‚ç‚¹æŒ‚è½½æ“ä½œã€‚

ğŸ“¢ æ³¨æ„ï¼šç”±äº`commitRoot`æ˜¯**ä¸€æ¬¡æ‰§è¡Œå®Œæˆçš„æŒ‚è½½è¿‡ç¨‹**ï¼Œä¸ºäº†é¿å…æµè§ˆå™¨äº§ç”Ÿé—ªçƒä»¥åŠé‡ç»˜ç­‰ï¼Œ`React`å†…éƒ¨è¿›è¡Œäº†ä¼˜åŒ–ï¼Œä¹Ÿå°±æ˜¯åœ¨`render`çš„`complete`é˜¶æ®µï¼Œå°±å°†å­æ ‘çš„æ•´ä¸ª`DOM`æ ‘æ„å»ºå®Œæˆäº†ï¼Œå¹¶å°†å…¶å¯¹åº”çš„`flags`å†’æ³¡åˆ°çˆ¶èŠ‚ç‚¹çš„`subtreeFlags`å±æ€§ä¸­ï¼Œåç»­åœ¨`commit`é˜¶æ®µç›´æ¥æ¯”è¾ƒè¯¥å±æ€§è¿›è¡Œç›¸åº”çš„å­æ ‘æŒ‚è½½å³å¯ã€‚ä¸‹é¢ä¼šè¿›è¡Œè¯¦ç»†çš„è§£æï¼š

#### renderRootSync

åœ¨`renderRootSync`å‡½æ•°ä¸­çš„æ ¸å¿ƒä¸º`do...while(true)`çš„æ‰§è¡Œ`workLoopSync`å‡½æ•°

```jsx
function renderRootSync(root, lanes) {
  prepareFreshStack(root, lanes);
  do {
    try {
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;

  return workInProgressRootExitStatus;
}

function prepareFreshStack(root, lanes) {
  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  workInProgressRoot = root;
  var rootWorkInProgress = createWorkInProgress(root.current, null);
  workInProgress = rootWorkInProgress;
  finishQueueingConcurrentUpdates();
  return rootWorkInProgress;
}

function createWorkInProgress(current, pendingProps) {
  var workInProgress = current.alternate;

  if (workInProgress === null) {
    // We use a double buffering pooling technique because we know that we'll
    // only ever need at most two versions of a tree. We pool the "other" unused
    // node that we're free to reuse. This is lazily created to avoid allocating
    // extra objects for things that are never updated. It also allow us to
    // reclaim the extra memory if needed.
    // åŒç¼“å­˜æœºåˆ¶ï¼Œåˆ›å»º alternate
    workInProgress = createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } else {
    workInProgress.pendingProps = pendingProps;
    workInProgress.type = current.type;
    workInProgress.flags = NoFlags;
    workInProgress.subtreeFlags = NoFlags;
    workInProgress.deletions = null;
  }

  workInProgress.flags = current.flags & StaticMask;
  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;
  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  var currentDependencies = current.dependencies;
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  return workInProgress;
}
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

function performUnitOfWork(unitOfWork) {
  var current = unitOfWork.alternate;
  setCurrentFiber(unitOfWork);
  var next;

  if ((unitOfWork.mode & ProfileMode) !== NoMode) {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  resetCurrentFiber();
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }

  ReactCurrentOwner$2.current = null;
}
```

ä¸Šé¢çš„ä»£ç ä¸­ï¼Œä¸»è¦å®ç°äº†ä¸¤éƒ¨åˆ†é‡è¦å†…å®¹ï¼š

- 1.åˆ›å»º`workInProgress`ï¼š`prepareFreshStack`å‡½æ•°å°†å½“å‰`FiberRootNode`ç±»å‹çš„èŠ‚ç‚¹ä¼ å…¥ï¼Œä½¿ç”¨å…¶`root.current`å±æ€§åˆ›å»º`workInProgress`ï¼Œ`root.current`ä¸ºå½“å‰å®¹å™¨çš„`FiberNode`èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯`FiberNode(HostRoot)`
- 2.å¼€å¯å·¥ä½œå¾ªç¯ï¼š`workLoopSync`ä»¥åŠ`performUnitOfWork`å‡½æ•°å®ç°äº†å¯¹`FiberTree`çš„åˆ›å»ºï¼Œå…¶ä¸­`beginWork`æ˜¯åˆ›å»º`FiberNode`ï¼Œ`completeUnitOfWork`ä¸ºåˆ›å»º`stateNode`å¹¶æ„å»ºä»¥å½“å‰èŠ‚ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„`DOM`æ ‘çš„è¿‡ç¨‹ã€‚

æ‰§è¡Œå®Œä¸Šé¢çš„å†…å®¹åï¼Œå½“å‰å†…å­˜ä¸­çš„æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-14.png)

##### workLoopSync

ä¸‹é¢æ˜¯`beginWork`å‡½æ•°çš„ä¸»è¦å†…å®¹ï¼Œä¸»è¦å°±æ˜¯æ ¹æ®`fiberNode`çš„`tag`å€¼æ‰§è¡Œä¸åŒçš„æ–¹æ³•

```jsx
function beginWork(current, workInProgress, renderLanes) {
  workInProgress.lanes = NoLanes;

  switch (workInProgress.tag) {
    case IndeterminateComponent: {
      return mountIndeterminateComponent(
        current,
        workInProgress,
        workInProgress.type,
        renderLanes,
      );
    }

    case FunctionComponent: {
      var Component = workInProgress.type;
      var unresolvedProps = workInProgress.pendingProps;
      var resolvedProps =
        workInProgress.elementType === Component
          ? unresolvedProps
          : resolveDefaultProps(Component, unresolvedProps);
      return updateFunctionComponent(
        current,
        workInProgress,
        Component,
        resolvedProps,
        renderLanes,
      );
    }

    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);

    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);

    case HostText:
      return updateHostText(current, workInProgress);
  }
}

function updateHostRoot(current, workInProgress, renderLanes) {
  var nextProps = workInProgress.pendingProps;
  var prevState = workInProgress.memoizedState;
  var prevChildren = prevState.element;
  var nextState = workInProgress.memoizedState;
  var root = workInProgress.stateNode;
  var nextChildren = nextState.element;

  reconcileChildren(current, workInProgress, nextChildren, renderLanes);
  return workInProgress.child;
}
```

è®©æˆ‘ä»¬ä»å¤´è¿›å…¥è¯¥å‡½æ•°ï¼Œäº†è§£ä¸€ä¸‹æ‰§è¡Œè¿‡ç¨‹ï¼Œç°åœ¨ä½¿ç”¨äº†å¦‚ä¸‹çš„ç»“æ„è¿›è¡Œæ¸²æŸ“ï¼š

```jsx
<App>
  <A>
    <div>
      <div>A</div>
      <div>B</div>
    </div>
  </A>
</App>
```

#### beginWork é˜¶æ®µ

##### **ç¬¬ä¸€æ¬¡ workLoop**

å‡½æ•°æ‰§è¡Œè¿‡ç¨‹å¦‚ä¸‹å›¾ï¼š
![alt text](./images/react-begin-loop1.png)

è¿™æ˜¯ç¬¬ä¸€æ¬¡`workLoop`å¾ªç¯ï¼Œå½“å‰çš„`workInProgress === FiberNode(HostRoot)`ï¼Œè¿›å…¥`beginWork`å‡½æ•°ï¼Œæ ¹æ®å½“å‰`tag === 3`ï¼Œè¿›å…¥`updateHostRoot`å‡½æ•°ï¼Œç„¶åè¿›å…¥`reconcileChildren`å‡½æ•°ä¸­ï¼Œæ­¤æ—¶ï¼Œä¼šå°† `root.render(<App />)`ä»£ç ä¸­çš„`<App />`å‡½æ•°ç»„ä»¶ï¼Œç»è¿‡`babel`ç¼–è¯‘åçš„`ReactElement`å¯¹è±¡ä½œä¸º`nextChildren`ä¼ å…¥`reconcileChildFibers`ä½œä¸ºå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸ºæ‰§è¡Œ`ChildReconciler(true)`åè¿”å›çš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯`ChildReconciler`å‡½æ•°ä¸­çš„é—­åŒ…`reconcileChildFibers`å‡½æ•°ï¼Œå…¶ä¸­`shouldTrackSideEffects`å‚æ•°ä¸º`true`ã€‚åé¢ç»§ç»­è¿›å…¥`reconcileSingleElement`å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„ä¸»è¦ä½œç”¨æ˜¯åˆ›å»º`FiberNode(<App />)`ï¼Œå¹¶å°†å…¶`return`å±æ€§ï¼ŒæŒ‡å‘å½“å‰`FiberNode(HostRoot)`ã€‚åç»­å°†å½“å‰æ–°åˆ›å»ºçš„`FiberNode(<App />)`ä½œä¸ºå‚æ•°ä¼ å…¥`placeSingleChild`å‡½æ•°ï¼Œæ·»åŠ `flags`ï¼Œå…¶`shouldTrackSideEffects === true`ï¼Œåˆ™`FiberNode(<App />).flags === Placement`ï¼Œæ‰§è¡Œåˆ°å½“å‰çš„å†…å­˜æ•°æ®æ¥å£å¦‚ä¸‹ï¼š

![alt text](./images/image-17.png)

ç„¶åä»`placeSingleChild`ä¾æ¬¡ä»è°ƒç”¨æ ˆä¸­è¿›è¡Œè¿”å›ï¼Œå…¶ä¸­æ¯”è¾ƒé‡è¦çš„å°±æ˜¯åœ¨`reconcileChildren`å‡½æ•°ä¸­ï¼Œå°†`workInProgress.child`å±æ€§æŒ‡å‘äº†æ–°åˆ›å»ºçš„`FiberNode(<App />)`èŠ‚ç‚¹ã€‚æ­¤æ—¶ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-18.png)

ç„¶ååœ¨`performUnitOfWork`å‡½æ•°ä¸­ï¼Œå°†`workInProgress`æŒ‡å‘äº†`FiberNode(<App />)`èŠ‚ç‚¹ã€‚æ­¤æ—¶ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-19.png)

##### **ç¬¬äºŒæ¬¡ workLoop**

æ­¤æ—¶è¿›å…¥ä¸‹ä¸€æ¬¡`workLoopSync`å¾ªç¯ï¼Œæµç¨‹å¦‚ä¸‹ï¼š
![alt text](./images/react-work-loop2.png)

å½“å‰å¾ªç¯ä¸ä¸Šä¸€æ¬¡å¾ªç¯ä¸åŒä¹‹å¤„åœ¨äºï¼Œæ­¤æ—¶çš„`FiberNode(<App />).tag === IndeterminateComponent`å¹¶ä¸”æ­¤æ—¶`workInProgress`çš„`current`ä¸º`null`ï¼Œäºæ˜¯è¿›å…¥`mountIndeterminateComponent`å‡½æ•°ï¼Œå°†è¯¥`FiberNode<App />.tag`ä¿®æ”¹ä¸º`FunctionComponent`ï¼Œç„¶åç»§ç»­æ‰§è¡Œ`renderWithHooks`å‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°å†…ï¼Œå¦‚æœæ˜¯å‡½æ•°ç»„ä»·ï¼Œåˆ™è·å–å…¶`type`ï¼Œä¹Ÿå°±æ˜¯å‡½æ•°æ¥è¿›è¡Œæ‰§è¡Œï¼Œæ‰§è¡Œå®Œæˆåçš„è¿”å›å€¼ï¼Œä¼ å…¥`reconcileChildren`å‡½æ•°å†…ï¼Œç”±äº`current === null`ï¼Œæ‰€ä»¥æ‰§è¡Œ`mountChildFibers`å‡½æ•°ï¼Œåˆ›å»º`FiberNode(<A />)`ï¼Œå½“å‰æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-22.png)

åœ¨å‡½æ•°è¿”å›åé€æ¸è¿”å›è°ƒç”¨æ ˆä¸­çš„å‡½æ•°ï¼Œå¹¶åœ¨`reconcileChildren`å‡½æ•°ä¸­å°†`workInProgress.child`æŒ‡å‘å½“å‰æ–°çš„ç»“ç‚¹`FiberNode(<A />)`ï¼Œå¹¶åœ¨`performUnitOfWork`å‡½æ•°ä¸­å°†å½“å‰æ–°åˆ›å»ºçš„ç»“ç‚¹æŒ‡å‘`workInProgress`ï¼Œå½“å‰æ•°æ®ç»“æ„å¦‚ä¸‹:
![alt text](./images/image-23.png)

##### **ç¬¬ä¸‰æ¬¡ workLoop**

ç»§ç»­æ‰§è¡Œç¬¬ä¸‰æ¬¡`workLoop`å¾ªç¯ï¼Œæµç¨‹å¦‚ä¸‹ï¼š
![alt text](./images/react-work-loop3.png)
å½“å‰å¾ªç¯ä¸ä¸Šæ¬¡å¾ªç¯è¿‡ç¨‹åŸºæœ¬ä¸€è‡´ï¼Œé™¤äº†ç”Ÿæˆçš„`FiberNode`çš„`tag === HostComponent`ç±»å‹ï¼Œè¿™æ˜¯åœ¨`createFiberFromTypeAndProps`å‡½æ•°ä¸­æ ¹æ®å½“å‰çš„`type`å€¼å†³å®šçš„ï¼Œå½“å‰`type === div`ï¼Œè¡¨ç¤ºä¸º**å®¿ä¸»ç»„ä»¶**ï¼Œåˆ™å°†`tag = HostComponent`ï¼Œå½“å‰æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-24.png)
ä¾æ¬¡è¿”å›è°ƒç”¨æ ˆä¸­çš„å‡½æ•°ï¼Œæœ¬è½®å¾ªç¯æ‰§è¡Œå®Œæˆåæ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-25.png)

##### **ç¬¬å››æ¬¡ workLoop**

![alt text](./images/react-work-loop4.png)

ç¬¬å››æ¬¡å¾ªç¯æµç¨‹å¦‚ä¸Šå›¾ ğŸ‘†ğŸ»ï¼Œå½“å‰`workInProgress === FiberNode(div)`ï¼Œåˆ™åœ¨`beginWork`å‡½æ•°ä¸­æ ¹æ®`tag === HostComponent`ï¼Œä¼šè¿›å…¥`updateHostComponent`å‡½æ•°ï¼Œ`babel`åœ¨ç¼–è¯‘æ—¶å°†`HostComponent`ç»„ä»¶çš„å­å…ƒç´ ä½œä¸º`children`å±æ€§æ”¾åœ¨äº†å…¶`element.props`ä¸­ï¼Œç„¶åå†åˆ›å»º`FiberNode`æ—¶ï¼Œä¿å­˜åœ¨äº†`FiberNode(div).pendingProps`å±æ€§ä¸­ã€‚å¦‚ä¸‹ä»£ç ï¼š

```jsx
function createFiberFromElement(element, mode, lanes) {
  var type = element.type;
  var key = element.key;
  var pendingProps = element.props;
  var fiber = createFiberFromTypeAndProps(
    type,
    key,
    pendingProps,
    owner,
    mode,
    lanes,
  );
  return fiber;
}
```

ç„¶åå†`updateHostComponent`ä¸­æ‰§è¡Œä¸‹é¢ä»£ç ï¼Œå°†å…¶å­å…ƒç´ ä¼ å…¥äº†`reconcileChildren`å‡½æ•°

```jsx
var nextProps = workInProgress.pendingProps;
var prevProps = current !== null ? current.memoizedProps : null;
var nextChildren = nextProps.children;
```

æ‰§è¡Œåˆ°`reconcileChildFibers`å‡½æ•°å†…éƒ¨ï¼Œå‘ç°å…¶`isArray(newChild) === true`ï¼Œåˆ™æ‰§è¡Œäº†`reconcileChildrenArray`å‡½æ•°

```jsx
function reconcileChildrenArray(
  returnFiber,
  currentFirstChild,
  newChildren,
  lanes,
) {
  var resultingFirstChild = null;
  var previousNewFiber = null;
  var oldFiber = currentFirstChild;
  var lastPlacedIndex = 0;
  var newIdx = 0;
  var nextOldFiber = null;

  if (oldFiber === null) {
    for (; newIdx < newChildren.length; newIdx++) {
      var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);

      if (_newFiber === null) {
        continue;
      }

      lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);

      if (previousNewFiber === null) {
        resultingFirstChild = _newFiber;
      } else {
        previousNewFiber.sibling = _newFiber;
      }

      previousNewFiber = _newFiber;
    }

    return resultingFirstChild;
  }
  return resultingFirstChild;
}
```

å½“å‰å‡½æ•°æ‰§è¡Œå®Œæˆåçš„å†…å­˜æ¨¡å‹å¦‚ä¸‹ï¼š
![alt text](./images/image-27.png)
å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç”Ÿæˆäº†å¯¹åº”çš„`FiberNode(div-A)`èŠ‚ç‚¹ï¼Œä»¥åŠ`FiberNode(div-B)`èŠ‚ç‚¹ï¼Œå¹¶å°†å…¶é€šè¿‡`sibling`å±æ€§è¿›è¡Œè¿æ¥ã€‚å¹¶ä¸”å®ƒä»¬çš„`return`èŠ‚ç‚¹éƒ½æŒ‡å‘äº†`FiberNode(div)`èŠ‚ç‚¹ã€‚

åç»­ä¾æ¬¡è¿”å›è°ƒç”¨æ ˆä¸­çš„å‡½æ•°ï¼Œæœ¬è½®å¾ªç¯æ‰§è¡Œå®Œæˆåæ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-29.png)

##### **ç¬¬äº”æ¬¡ workLoop**

è¿›å…¥ç¬¬äº”æ¬¡`workLoop`å¾ªç¯ä¸­çš„`beginWork`å‡½æ•°ï¼Œå½“å‰`workInProgress === FiberNode(div-A)`ï¼Œæµç¨‹å¦‚ä¸‹ï¼š
![alt text](./images/react-work-loop5.png)ï¼Œå¤§è‡´æµç¨‹ä¸ä¸Šæ¬¡å¾ªç¯ä¸€è‡´ï¼Œä¸åŒç‚¹ä¸ºæ²¡æœ‰å…¶å­å…ƒç´ ï¼Œå‡½æ•°è¿”å›çš„ä¸º`null`ï¼Œå…¶æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œäºæ˜¯è¿›å…¥`performUnitOfWork`å‡½æ•°ä¸­çš„`completeUnitOfWork`å‡½æ•°ã€‚å½“å‰å†…å­˜ä¸­æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-30.png)

ä¸Šé¢æ•´ä¸ª`beginWork`é˜¶æ®µå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
![alt text](./images/beginWork.png)

#### completeUnitOfWork é˜¶æ®µ

ä¸Šé¢çš„`beginWork`æ‰§è¡Œåˆ°`FiberNode(div-A)`èŠ‚ç‚¹åï¼Œè¿”å›çš„`workInProgress.child === null`ï¼Œè¡¨æ˜`FiberNode(div-A)`ä¸‹é¢æ²¡æœ‰å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¼šå°†`FiberNode(div-A)`èŠ‚ç‚¹ä¼ å…¥`completeUnitOfWork`å‡½æ•°ï¼Œè¿›å…¥`complete`é˜¶æ®µã€‚

```jsx
function completeUnitOfWork(unitOfWork) {
  var completedWork = unitOfWork;

  do {
    var current = completedWork.alternate;
    var returnFiber = completedWork.return;

    if (completedWork.flags & (Incomplete === NoFlags)) {
      setCurrentFiber(completedWork);
      var next = void 0;

      next = completeWork(current, completedWork, subtreeRenderLanes);
      resetCurrentFiber();

      if (next !== null) {
        workInProgress = next;
        return;
      }
    } else {
      if (returnFiber !== null) {
        // è®¾ç½®çˆ¶èŠ‚ç‚¹çš„æ ‡è¯†ä¸º Incompleteï¼Œé‡ç½®å­æ ‘çš„æ ‡è¯†ä½ä¸º NoFlagsï¼Œåˆ é™¤çˆ¶èŠ‚ç‚¹çš„ deletions
        returnFiber.flags |= Incomplete;
        returnFiber.subtreeFlags = NoFlags;
        returnFiber.deletions = null;
      } else {
        workInProgress = null;
        return;
      }
    }

    var siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
function completeWork(current, workInProgress, renderLanes) {
  var newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case IndeterminateComponent:
    case LazyComponent:
    case SimpleMemoComponent:
    case FunctionComponent:
    case ForwardRef:
    case Fragment:
    case Mode:
    case Profiler:
    case ContextConsumer:
    case MemoComponent:
      bubbleProperties(workInProgress);
      return null;
    case HostRoot:
      bubbleProperties(workInProgress);
      return null;
    case HostComponent: {
      var type = workInProgress.type;
      var rootContainerInstance = workInProgressRoot.current;
      if (current !== null && workInProgress.stateNode !== null) {
        updateHostComponent(current, workInProgress, type, newProps);
      } else {
        var instance = createInstance(
          type,
          newProps,
          rootContainerInstance,
          workInProgress,
        );
        appendAllChildren(instance, workInProgress, false, false);
        workInProgress.stateNode = instance;
      }
      bubbleProperties(workInProgress);
      return null;
    }
    default:
      return null;
  }
}

function updateHostComponent(current, workInProgress, type, newProps) {
  var type = workInProgress.type;
  var nextProps = workInProgress.pendingProps;
  var prevProps = current !== null ? current.memoizedProps : null;
  var nextChildren = nextProps.children;

  var isDirectTextChild = shouldSetTextContent(type, nextProps);

  if (isDirectTextChild) {
    nextChildren = null;
  }
  reconcileChildren(current, workInProgress, nextChildren, NoLanes);
  return workInProgress.child;
}

function appendAllChildren(
  parent,
  workInProgress,
  needsVisibilityToggle,
  isHidden,
) {
  var node = workInProgress.child;

  while (node !== null) {
    // æ·±åº¦ä¼˜å…ˆéå†ï¼Œæ‰¾åˆ°ç±»å‹æ˜¯ HostComponent æˆ– HostText çš„èŠ‚ç‚¹ï¼Œæ‰å¹¶å°†å…¶æ·»åŠ åˆ°çˆ¶èŠ‚ç‚¹ä¸­
    if (node.tag === HostComponent || node.tag === HostText) {
      appendInitialChild(parent, node.stateNode);
    } else if (node.child !== null) {
      // å¦‚æœå­èŠ‚ç‚¹å­˜åœ¨ï¼Œåˆ™å°†å­èŠ‚ç‚¹çš„ return æŒ‡é’ˆæŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼Œç„¶åç»§ç»­éå†å­èŠ‚ç‚¹
      node.child.return = node;
      node = node.child;
      continue;
    }

    if (node === workInProgress) {
      return;
    }

    // å¦‚æœå½“å‰èŠ‚ç‚¹æ²¡æœ‰å…„å¼ŸèŠ‚ç‚¹ï¼Œåˆ™ç»§ç»­éå†çˆ¶èŠ‚ç‚¹
    while (node.sibling === null) {
      if (node.return === null || node.return === workInProgress) {
        return;
      }

      node = node.return;
    }

    node.sibling.return = node.return;
    node = node.sibling;
  }
}

// ä¸€ç›´å¾€åæ’å…¥å­å…ƒç´ 
function appendInitialChild(parentInstance, child) {
  parentInstance.appendChild(child);
}
```

##### Loop1

![alt text](./images/complete1.png)

æ‰§è¡Œå®Œæˆåå½“å‰çš„å†…å­˜æ•°æ®ç»“æ„å¦‚ä¸‹å›¾ï¼š
![alt text](./images/complete-data1.png)

##### Loop2

ä¸Šé¢ä»£ç ä¹‹å‰å®Œæˆä¹‹åï¼Œä¼šè¿›å…¥`completeUnitOfWork`å‡½æ•°ä¸­çš„ä¸‹é¢ä»£ç ï¼Œè·å–å½“å‰èŠ‚ç‚¹çš„å…„å¼Ÿå…ƒç´ ï¼Œå¦‚æœå­˜åœ¨å…„å¼Ÿå…ƒç´ ï¼Œèµ‹å€¼ç»™`workInProgress`å˜é‡ï¼Œé‡æ–°è¿›å…¥`beginWork`é˜¶æ®µï¼Œæ‰§è¡Œåå…¶`workInProgress.child === null`ï¼Œåˆ™ç»§ç»­æ‰§è¡Œ`completeUnitOfWork`å‡½æ•°ï¼š

```jsx
var siblingFiber = completedWork.sibling;
if (siblingFiber !== null) {
  workInProgress = siblingFiber;
  return;
}
```

æ‰§è¡Œæµç¨‹å¦‚ä¸‹å›¾ï¼š
![alt text](./images/complete2.png)

å†…å­˜ä¸­æ•°æ®æ¨¡å‹å¦‚ä¸‹å›¾ï¼š
![alt text](./images/image-31.png)

æ‰§è¡Œå®Œæˆ`completeWork`çš„`FiberNode(div-B)`èŠ‚ç‚¹åï¼Œå‘ç°å…¶æ²¡æœ‰å…„å¼ŸèŠ‚ç‚¹ï¼Œåˆ™è¿›å…¥å¦‚ä¸‹ä»£ç ï¼Œè·å–å…¶å½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå¹¶ç»§ç»­æ‰§è¡Œ`do...while`å¾ªç¯ï¼š

```jsx
do {
  var returnFiber = completedWork.return;
  completedWork = returnFiber;
  workInProgress = completedWork;
} while (completedWork !== null);
```

å…¶æµç¨‹å›¾å¦‚ä¸‹ï¼š
![alt text](./images/complete3.png)

è¿™ä¸ªè¿‡ç¨‹éœ€è¦æ³¨æ„ ğŸ“¢ çš„æ˜¯ï¼Œåœ¨`appendAllChildren`å‡½æ•°ä¸­ï¼Œä¼šå°†å…¶`child`ä»¥åŠå…¶æ‰€æœ‰å…„å¼Ÿå…ƒç´ æ’å…¥åˆ°å½“å‰`FiberNode(div)`çš„`DOM`ä¸­ï¼Œä¹Ÿå°±æ˜¯ï¼Œä¼šå°†`FiberNode(div-A)`ä»¥åŠ`FiberNode(div-B)`çš„`DOM`èŠ‚ç‚¹éƒ½æ’å…¥è¿›å»ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢æ‰€è¯´çš„ï¼Œä¼šæ„å»ºä»¥å½“å‰èŠ‚ç‚¹ä¸º**æ ¹èŠ‚ç‚¹**çš„å®Œæ•´`DOM`æ ‘ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä¼šæ‰§è¡Œ`bubbleProperties`å‡½æ•°ï¼Œå°†å…¶å­èŠ‚ç‚¹çš„`flags`å±æ€§åˆå¹¶åˆ°å½“å‰èŠ‚ç‚¹çš„`subtreeFlags`å±æ€§ä¸­ã€‚

å†…å­˜ä¸­æ•°æ®æ¨¡å‹å¦‚ä¸‹å›¾ï¼š
![alt text](./images/image-32.png)

å®Œæˆå½“å‰èŠ‚ç‚¹`FiberNode(div)`çš„`complete`èŠ‚ç‚¹ï¼Œå‘ç°å…¶æ²¡æœ‰`sibling`èŠ‚ç‚¹ï¼Œåˆ™ç»§ç»­è·å–å…¶çˆ¶èŠ‚ç‚¹`returnFiber`ç»§ç»­æ‰§è¡Œ`completeWork`å‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°å†…æ ¹æ®ç±»å‹åˆ¤æ–­ä¸º`FunctionComponent`ï¼Œåˆ™è¿›å…¥`bubbleProperties`å‡½æ•°ã€‚è¿™æ˜¯ä¸ä¸Šé¢çš„æœ€å¤§åŒºåˆ«ï¼Œä¸Šé¢æ‰§è¡Œæ—¶èµ·`FiberNode`çš„ç±»å‹ä¸º`HostComponent`ï¼Œæ‰€ä»¥æ‰§è¡Œåˆ›å»ºä»¥åŠæ’å…¥`DOM`æ“ä½œï¼Œè€Œ`FunctionComponent`ç±»å‹æ˜¯åœ¨`react`ä¸­å®šä¹‰çš„ç»„ä»¶ç±»å‹ï¼Œæ²¡æœ‰å¯¹åº”çš„å®¿ä¸»å…ƒç´ ï¼Œåªéœ€è¦æ‰§è¡Œ`bubbleProperties`å‡½æ•°å³å¯ï¼Œä¹Ÿå°±æ˜¯å°†å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹çš„å±æ€§å†’æ³¡åˆ°å½“å‰èŠ‚ç‚¹ä¸­ï¼Œæ–¹ä¾¿åœ¨åç»­`commit`é˜¶æ®µå¯¹çˆ¶èŠ‚ç‚¹çš„å±æ€§è¿›è¡Œå¯¹æ¯”ï¼Œç›´æ¥æŒ‚è½½æ•´ä¸ª`DOM`æ ‘ï¼Œå‡å°‘å¯¹`FiberTree`çš„éå†æ“ä½œã€‚

```jsx
function bubbleProperties(completedWork) {
  var didBailout =
    completedWork.alternate !== null &&
    completedWork.alternate.child === completedWork.child;
  var newChildLanes = NoLanes;
  var subtreeFlags = NoFlags;

  if (!didBailout) {
    if ((completedWork.mode & ProfileMode) !== NoMode) {
      while (child !== null) {
        newChildLanes = mergeLanes(
          newChildLanes,
          mergeLanes(child.lanes, child.childLanes),
        );
        subtreeFlags |= child.subtreeFlags;
        subtreeFlags |= child.flags;
        child = child.sibling;
      }

      completedWork.actualDuration = actualDuration;
      completedWork.treeBaseDuration = treeBaseDuration;
    } else {
      var _child = completedWork.child;

      while (_child !== null) {
        newChildLanes = mergeLanes(
          newChildLanes,
          mergeLanes(_child.lanes, _child.childLanes),
        );
        subtreeFlags |= _child.subtreeFlags;
        subtreeFlags |= _child.flags;

        _child.return = completedWork;
        _child = _child.sibling;
      }
    }
  }

  completedWork.subtreeFlags |= subtreeFlags;

  completedWork.childLanes = newChildLanes;
  return didBailout;
}
```

æµç¨‹å›¾å¦‚ä¸‹ï¼š
![alt text](./images/image-33.png)

å½“å‰å†…å­˜æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-3.png)

å®Œæˆå½“å‰èŠ‚ç‚¹`FiberNode(A)`çš„`complete`èŠ‚ç‚¹ï¼Œå‘ç°å…¶æ²¡æœ‰`sibling`èŠ‚ç‚¹ï¼Œåˆ™ç»§ç»­è·å–å…¶çˆ¶èŠ‚ç‚¹`returnFiber`ï¼Œå…¶çˆ¶èŠ‚ç‚¹ä¸º`FiberNode(App)`ï¼Œç»§ç»­æ‰§è¡Œ`completeWork`å‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°å†…æ ¹æ®ç±»å‹åˆ¤æ–­ä¸º`FunctionComponent`ï¼Œåˆ™è¿›å…¥`bubbleProperties`å‡½æ•°ã€‚æµç¨‹å›¾å¦‚ä¸‹ï¼š

![alt text](./images/image-34.png)
ä¸ä¸Šé¢æµç¨‹ä¸åŒçš„æ˜¯ï¼Œå½“å‰çš„`FiberNode(App)`åœ¨`beginWork`é˜¶æ®µåˆ›å»º`FiberNode`æ—¶ï¼Œæ‰§è¡Œäº†ä¸‹é¢ä»£ç ï¼Œå°†å…¶`flags`è®¾ç½®ä¸ºäº†`Placement`

```jsx
function placeSingleChild(newFiber) {
  // This is simpler for the single child case. We only need to do a
  // placement for inserting new children.
  if (shouldTrackSideEffects && newFiber.alternate === null) {
    newFiber.flags |= Placement;
  }

  return newFiber;
}
```

æ‰§è¡Œå®Œæˆåï¼Œå…¶å†…å­˜çš„æ•°æ®ç»“æ„å¦‚ä¸‹å›¾ï¼š
![alt text](./images/image-35.png)

å®Œæˆå½“å‰èŠ‚ç‚¹`FiberNode(App)`çš„`complete`èŠ‚ç‚¹ï¼Œå‘ç°å…¶æ²¡æœ‰`sibling`èŠ‚ç‚¹ï¼Œåˆ™ç»§ç»­è·å–å…¶çˆ¶èŠ‚ç‚¹`returnFiber`ç»§ç»­æ‰§è¡Œ`completeWork`å‡½æ•°ï¼Œå…¶çˆ¶èŠ‚ç‚¹ä¸º`FiberNode(HostRoot)`ï¼Œåœ¨è¯¥å‡½æ•°å†…æ ¹æ®ç±»å‹åˆ¤æ–­ä¸º`HostRoot`ï¼Œç»§ç»­æ‰§è¡Œ`bubbleProperties`å‡½æ•°ã€‚

![alt text](./images/image-36.png)

æ­¤æ—¶å†…å­˜çš„æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š

![alt text](./images/image-7.png)

å®Œæˆå½“å‰èŠ‚ç‚¹`FiberNode(HostRoot)`çš„`complete`èŠ‚ç‚¹ï¼Œå‘ç°å…¶æ²¡æœ‰`sibling`èŠ‚ç‚¹ï¼Œå°†å…¶`workInProgress`è®¾ç½®ä¸ºçˆ¶èŠ‚ç‚¹`returnFiber`ï¼Œå½“å‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹`return`ä¸º`null`ï¼Œåˆ™è·³å‡ºæ•´ä¸ª`workLoopSync`å¾ªç¯ï¼Œå®Œæˆäº†æ•´ä¸ª`render`é˜¶æ®µã€‚æ•´ä¸ª`complete`é˜¶æ®µçš„æµç¨‹å›¾å¦‚ä¸‹ï¼š

![alt text](./images/render-complete.png)

### commit

å®Œæˆ`render`é˜¶æ®µåï¼Œæ•´ä¸ª`FiberTree`è¢«æ„å»ºå®Œæˆï¼Œå¹¶ä¸”æ¯ä¸ª`FiberNode`èŠ‚ç‚¹éƒ½è¢«æ·»åŠ äº†å¯¹åº”éœ€è¦çš„å±æ€§ï¼Œå¦‚`stateNode`ï¼Œ`flags`ï¼Œ`subtreeFlags`ç­‰ç­‰ï¼Œè¿™äº›å±æ€§ä¼šåœ¨`commit`é˜¶æ®µè¢«ä½¿ç”¨åˆ°ã€‚

ä¸‹é¢æ˜¯æäº¤é˜¶æ®µçš„ç›¸å…³ä»£ç ï¼š

```jsx
function commitRoot(root, recoverableErrors, transitions) {

  try {
    commitRootImpl(root, recoverableErrors, transitions, previousUpdateLanePriority);
  } finally {
  }

  return null;
}

function commitRootImpl(root, recoverableErrors, transitions, renderPriorityLevel) {
  var finishedWork = root.finishedWork;
  var lanes = root.finishedLanes

  root.finishedWork = null;
  root.finishedLanes = NoLanes;

  root.callbackNode = null;
  root.callbackPriority = NoLane;

  if (root === workInProgressRoot)
    workInProgressRoot = null;
    workInProgress = null;
    workInProgressRootRenderLanes = NoLanes;
  }
  var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
  var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;

  if (subtreeHasEffects || rootHasEffect) {
    commitMutationEffects(root, finishedWork, lanes);
    root.current = finishedWork;
  } else {
    root.current = finishedWork;
  }
  return null;
}

function commitMutationEffects(root, finishedWork, committedLanes) {
  inProgressLanes = committedLanes;
  inProgressRoot = root;
  setCurrentFiber(finishedWork);
  commitMutationEffectsOnFiber(finishedWork, root);
  setCurrentFiber(finishedWork);
  inProgressLanes = null;
  inProgressRoot = null;
}

function commitMutationEffectsOnFiber(finishedWork, root, lanes) {
  var current = finishedWork.alternate;
  var flags = finishedWork.flags;

  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case MemoComponent:
    case SimpleMemoComponent:
      {
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);

        if (flags & Update) {
          try {
            commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
            commitHookEffectListMount(Insertion | HasEffect, finishedWork);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }

        return;
      }

    case HostComponent:
      {
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        return;
      }

    case HostText:
      {
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        return;
      }

    case HostRoot:
      {
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        return;
      }

    default:
      {
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        return;
      }
  }
}
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œåœ¨æ‰§è¡Œ`commitRoot`å‡½æ•°ä¹‹å‰ï¼Œä¼šæ‰§è¡Œä¸‹é¢è¿‡ç¨‹

```jsx
var finishedWork = root.current.alternate;
root.finishedWork = finishedWork;
root.finishedLanes = lanes;
```

å½“å‰å†…å­˜ä¸­çš„æ•°æ®æ¨¡å‹å¦‚ä¸‹å›¾ï¼š
![alt text](./images/image-9.png)

ä»ä¸Šé¢æ•°æ®æ¨¡å‹å¯ä»¥çœ‹åˆ°ï¼Œä¼ å…¥`recursivelyTraverseMutationEffects`å‡½æ•°çš„å‚æ•°ä¸º`root === FiberRootNode`ï¼Œ`parentFiber === finishedWork === FiberNode(HostRoot)`ï¼Œè¯¥å‡½æ•°å¦‚ä¸‹ï¼š

```jsx
function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {
  // ...other code
  var prevDebugFiber = getCurrentFiber();
  if (parentFiber.subtreeFlags & MutationMask) {
    var child = parentFiber.child;
    while (child !== null) {
      setCurrentFiber(child);
      commitMutationEffectsOnFiber(child, root);
      child = child.sibling;
    }
  }
  setCurrentFiber(prevDebugFiber);
}
```

å‡½æ•°`recursivelyTraverseMutationEffects`ä¸­çš„å†…å®¹ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œåˆ¤æ–­å½“å‰`finishedWork`ä¸­çš„`subtreeFlags`æ ‡è¯†ä½ä¸­æ˜¯å¦åŒ…å«æŒ‚è½½æ ‡è¯†ï¼Œå¦‚æœåŒ…å«ï¼Œåˆ™ç»§ç»­è°ƒç”¨`commitMutationEffectsOnFiber`å‡½æ•°ï¼Œå¯¹æ•´ä¸ª`FiberTree`è¿›è¡Œéå†æ“ä½œã€‚å½“å‰æµç¨‹å¦‚ä¸‹ï¼š
![alt text](./images/image-10.png)

ç»§ç»­è°ƒç”¨`commitMutationEffectsOnFiber`å‡½æ•°ï¼Œç»§ç»­æ‰§è¡Œ`recursivelyTraverseMutationEffects`å‡½æ•°ï¼Œå…¶å‚æ•°`parentFiber === finishedWork === FiberNode(App))`ï¼Œæ¯”è¾ƒå…¶`subtreeFlags & MutationMask === 0`ï¼Œä¸è¿›å…¥`if`æ¡ä»¶è¯­å¥ä¸­ï¼Œè¿”å›ä¸Šçº§å‡½æ•°ï¼Œæ‰§è¡Œ`commitReconciliationEffects`è¿›è¡Œæäº¤æ“ä½œï¼Œå…¶æµç¨‹å¦‚ä¸‹ï¼š
![alt text](./images/image-11.png)

å…¶è°ƒç”¨æ ˆå¦‚ä¸‹å›¾ï¼š
![alt text](./images/image-12.png)
å¯ä»¥ä»ä¸Šé¢çš„è°ƒç”¨æ ˆçœ‹åˆ°ï¼Œè¿›å…¥äº†ä¸¤æ¬¡`commitMutationEffectsOnFiber`å‡½æ•°ï¼Œæœ€è¿‘ä¸€æ¬¡çš„`recursivelyTraverseMutationEffects`å‡½æ•°ç”±äºä¸è¿›å…¥`if`æ¡ä»¶è¯­å¥ä¸­ï¼Œäºæ˜¯è¢«å¼¹å‡ºè°ƒç”¨æ ˆï¼Œæ‰§è¡Œä¸‹é¢çš„å‡½æ•°`commitReconciliationEffects`ã€‚

```jsx
function commitReconciliationEffects(finishedWork)
  var flags = finishedWork.flags
  if (flags & Placement) {
    try {
      commitPlacement(finishedWork);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }

    finishedWork.flags &= ~Placement;
  }
}
function commitPlacement(finishedWork) {
  var parentFiber = getHostParentFiber(finishedWork);
  switch (parentFiber.tag) {
    case HostComponent: {
      var parent = parentFiber.stateNode;
      var before = getHostSibling(finishedWork);
      insertOrAppendPlacementNode(finishedWork, before, parent);
      break;
    }

    case HostRoot:
    case HostPortal: {
      var _parent = parentFiber.stateNode.containerInfo;
      var _before = getHostSibling(finishedWork);
      insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
      break;
    }
  }
}
function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
  var tag = node.tag;
  var isHost = tag === HostComponent || tag === HostText;
  if (isHost) {
    var stateNode = node.stateNode;
    if (before) {
      insertInContainerBefore(parent, stateNode, before);
    } else {
      appendChildToContainer(parent, stateNode);
    }
  } else if (tag === HostPortal);
  else {
    var child = node.child;
    if (child !== null) {
      insertOrAppendPlacementNodeIntoContainer(child, before, parent);
      var sibling = child.sibling;
      while (sibling !== null) {
        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
        sibling = sibling.sibling;
      }
    }
  }
}
```

å½“å‰å†…å­˜ä¸­çš„æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š
![alt text](./images/image-37.png)

åç»­æµç¨‹å›¾å¦‚ä¸‹ï¼š
![alt text](./images/react-commit.png)
