# bit 位运算

本页面中主要记录在`React`源码中的位运算

## 位运算在权限系统中的使用

传统的权限系统重，存在很多的关联关系，如用户和权限的关联，用户和角色的关联。系统越大，关联关系越多，越难以维护。而引入位运算，可以巧妙的解决这个问题。

- 每种权限码都是唯一的
- 所有权限码的二进制数形式，有且只有一位值为 1，其与全部为 0(`2^n`)

如果用户权限和权限码全部使用二进制数字表示，再结合或运算`|`或者与运算`&`可以进行：

- `|`或运算可以用来赋予权限
- `&`与运算可以用来校验权限

如在`Linux`系统中的文件权限，其分为读、写以及执行，有字母和数字等多种表现形式

| 权限     | 字母表示 | 数字表示 | 二进制  |
| -------- | -------- | -------- | ------- |
| 读权限   | r        | 4        | `0b100` |
| 写权限   | w        | 2        | `0b010` |
| 执行权限 | x        | 1        | `0b001` |
| 无权限   | -        | 0        | `0b000` |

### 添加权限

```ts
let r = 0b100;
let w = 0b010;
let x = 0b001;

// 给用户赋予全部权限，使用或|操作，结果为 0b111;
let user = r | w | x;
```

### 校验权限

```ts
let r = 0b100;
let w = 0b010;
let x = 0b001;

// 给用户赋予全部权限，使用或|操作，结果为 0b110;
let user = r | w;

//   user: 0b110
//      r: 0b100
// user&r: 0b100
console.log((user & r) === r); // true，有r权限
//   user: 0b110
//      w: 0b010
// user&w: 0b010
console.log((user & w) === w); // true，有w权限
//   user: 0b110
//      x: 0b001
// user&x: 0b000
console.log((user & x) === x); // false，没有x权限
```

根据上面代码可以使用 **用户权限 & 权限 code === 权限 code** 是否为`true`来判断是否有该权限

### 删除权限

```ts
let r = 0b100;
let w = 0b010;
let x = 0b001;

let user = 0b110; // 有 r w 两个权限

// 执行异或操作
//     user: 0b110;
//        r: 0b100;
// user ^ r: 0b010;
user = user ^ r;
//   user: 0b010
//      r: 0b100
// user&r: 0b000
console.log((user & r) === r); // false，没有r权限
//   user: 0b010
//      w: 0b010
// user&w: 0b010
console.log((user & w) === w); // true，有w权限
//   user: 0b010
//      x: 0b001
// user&x: 0b000
console.log((user & x) === x); // false，没有x权限

// 再执行一次异或操作
//     user: 0b010;
//        r: 0b100;
// user ^ r: 0b110;
user = user ^ r;
```

在上面的执行过程中，先使用异或操作删除了`r`权限，但是再次对`user`进行`r`的异或操作，发现原本没有`r`权限的值再异或结果后又有了其权限的值，这样是不正常的。

如果想只是删除权限（而不是无则增，有则减），需要怎么做呢？答案是执行 `&(~code)`，先取反，再执行与操作

```ts
let r = 0b100;
let w = 0b010;
let x = 0b001;

let user = 0b110; // 有 r w 两个权限

// 执行删除&(~code)操作
//      user: 0b110;
//        ~r: 0b011;
// user & ~r: 0b010;
user = user & ~r;
//   user: 0b010
//      r: 0b100
// user&r: 0b000
console.log((user & r) === r); // false，没有r权限
//   user: 0b010
//      w: 0b010
// user&w: 0b010
console.log((user & w) === w); // true，有w权限
//   user: 0b010
//      x: 0b001
// user&x: 0b000
console.log((user & x) === x); // false，没有x权限

// 再执行一次删除操作
//      user: 0b010;
//        ~r: 0b011;
// user & ~r: 0b010;
user = user & ~r;
```

可以看到，当前面删除完`r`权限之后，再使用`&(~code)`执行删除操作，其结果都是一致的，不会出现**无则增，有则减**的现象

### 局限性和解决办法

上面的权限运算都有前提条件，也就是：

- 每种权限码都是唯一的
- 所有权限码的二进制数形式，有且只有一位值为 1，其与全部为 0(`2^n`)

那么在同一个应用下可用的权限数就非常有限，这也是该方案的局限性。为了突破这个限制，提出了一个叫做“权限空间”的概念，既然权限数量有限，那么就可以多开辟几个空间来存放。
