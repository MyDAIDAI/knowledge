# React åŸç†ä¹‹ Fiber

## åˆ›å»º`FiberRootNode`

åœ¨æ¸²æŸ“é¡µé¢æ—¶ä½¿ç”¨äº†ä¸‹é¢æ–¹æ³•æ¥è¿›è¡Œ`JSX`ä¸`DOM`å®¹å™¨çš„å…³è”

```ts
createRoot(document.getElementById("root")!).render(<App />);
```

è¯¦ç»†è¿›å…¥`createRoot`å¯ä»¥çœ‹åˆ°ï¼š

```ts
export function createRoot(container) {
  const root = createContainer(container);
  return {
    render(element) {
      return updateContainer(element, root);
    },
  };
}
```

å¯ä»¥çœ‹åˆ°ä¸»è¦æ‰§è¡Œäº†ä¸¤ä¸ªæ–¹æ³•ï¼Œå°±å®Œæˆäº†`JSX`çš„è½¬æ¢ä»¥åŠ`DOM`æ ‘çš„æ¸²æŸ“è¿‡ç¨‹ï¼Œé‚£ä¹ˆæ˜¯è¿‡ç¨‹æ˜¯æ€ä¹ˆæ ·çš„å‘¢ï¼Œä¸‹é¢ ğŸ‘‡ğŸ» æˆ‘ä»¬åˆ†æ­¥éª¤æ¥è¿›è¡Œè§£æï¼Œé¦–å…ˆè¿›å…¥`createContainer`æ–¹æ³•

```ts
export function createContainer(container: Container) {
  const hostRootFiber = new FiberNode(HostRoot, {}, null);
  const root = new FiberRootNode(container, hostRootFiber);
  hostRootFiber.updateQueue = createUpdateQueue<ReactElement>();
  return root;
}
```

åœ¨ä¸Šé¢çš„æ–¹æ³•ä¸­å¯ä»¥çœ‹åˆ°ï¼Œä¸»è¦æ˜¯åˆ›å»ºäº†ä¸¤ä¸ªå®ä¾‹ï¼Œä¸€ä¸ªæ˜¯`hostRootFiber`ï¼Œä¸€ä¸ªæ˜¯`root`ï¼Œå¹¶ä¸”è°ƒç”¨`createUpdateQueue`åˆ›å»ºäº†ä¸€ä¸ªæ›´æ–°é˜Ÿåˆ—ï¼Œå°±æ˜¯è¿”å›äº†ä¸€ä¸ªç»“æ„ä¸º`{ shared: { pending: null }}`çš„å¯¹è±¡ï¼Œè¯¥å¯¹è±¡çš„å€¼ç°åœ¨ä¸º`null`ï¼ŒåæœŸåœ¨ç¬¬äºŒé˜¶æ®µä¼šå°†å…¶æŒ‡å‘ä¸ºéœ€è¦æ›´æ–°çš„`<App />`

```ts
export const createUpdateQueue = <Action>() => {
  const updateQueue: UpdateQueue<Action> = {
    shared: {
      pending: null,
    },
    dispatch: null,
  };
  return updateQueue;
};
```

`hostRootFiber`æ˜¯ä¸€ä¸ª`FiberNode`çš„å®ä¾‹ï¼Œå…¶`type`å€¼ä¸º`HostRoot`ï¼Œä¹Ÿå°±æ˜¯å‡­ç©ºåˆ›å»ºäº†ä¸€ä¸ªé¡¶çº§çš„`FiberNode`èŠ‚ç‚¹

`root`æ˜¯`FiberRootNode`çš„å®ä¾‹ï¼Œåœ¨è¿™ä¸ªå®ä¾‹å¯¹è±¡ä¸­ï¼Œå°†`hostRootFiber`ä¸`DOM`èŠ‚ç‚¹è¿›è¡Œäº†å…³è”ï¼Œåœ¨å†…å­˜ä¸­ç”Ÿæˆäº†å¦‚ä¸‹æ•°æ®æ¨¡å‹
![02.1](image-2.png)

![02.2](image.png)

è¯¦ç»†æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š

- `root`ç»“æ„

```json
callbackNode:null
callbackPriority:0
container:div#root
current:FiberNode {tag: 3, key: null, stateNode: FiberRootNode, type: null, return: null, â€¦}
finishedLanes:0
finishedWork:null
pendingLanes:0
pendingPassiveEffects:{unmount: Array(0), update: Array(0)}
```

- `hostRootFiber`ç»“æ„

```json
alternate:null
child:null
deletions:null
flags:0
index:0
key:null
lanes:0
memoizedProps:null
memoizedState:null
pendingProps:{}
ref:null
return:null
sibling:null
stateNode:FiberRootNode {container: div#root, current: FiberNode, finishedWork: null, pendingPassiveEffects: {â€¦}, pendingLanes: 0, â€¦}
subtreeFlags:0
tag:3
type:null
updateQueue:{shared: {pending: null}}
```

## `updateContainer`

åœ¨åˆ›å»ºäº†ä¸€ä¸ªæ ¹`fiber`çš„`root`èŠ‚ç‚¹ï¼Œå¹¶ä¸”å°†å…¶ä¸å®¹å™¨`DOM`è¿›è¡Œå…³è”ä¹‹åï¼Œæ‰§è¡Œäº†`updateContainer`å‡½æ•°ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­å°†éœ€è¦æ›´æ–°çš„`JSX`æ”¾å…¥äº†æ›´æ–°é˜Ÿåˆ—`updateQueue`ä¸­ï¼Œå¹¶ä½¿ç”¨çš„æ·±åº¦ä¼˜å…ˆéå†è¿›è¡Œå­æ ‘çš„`FiberNode`çš„åˆ›å»º

```ts
export function updateContainer(
  element: ReactElement | null,
  root: FiberRootNode
) {
  const hostRootFiber = root.current;
  const update = createUpdate<ReactElement | null>(element, rootRenderPriority);
  enqueueUpdate(
    hostRootFiber.updateQueue as UpdateQueue<ReactElement | null>,
    update
  );
  scheduleUpdateOnFiber(hostRootFiber, rootRenderPriority);
  return element;
}
```

ä¸Šé¢çš„`createUpdate`å‡½æ•°å¾ˆç®€å•ï¼Œå°±æ˜¯è¿”å›äº†ä¸€ä¸ªå¯¹è±¡ï¼Œå…¶ä¸­`action`æŒ‡å‘éœ€è¦æ›´æ–°çš„`ReactElement`å…ƒç´ ï¼Œä¹Ÿå°±æ˜¯`<App />`

```ts
action: {$$typeof: Symbol(react.element), key: null, ref: null, props: {â€¦}, type: Æ’, â€¦}
lane: 1
next: null
```

ç„¶åæ‰§è¡Œ`enqueueUpdate`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸»è¦æ˜¯å°†ä¹‹å‰è¿”å›çš„`update`ä»»åŠ¡åŠ å…¥åˆ°æ›´æ–°é˜Ÿåˆ—ä¸­ï¼Œæ­¤æ—¶ç”±äºæ˜¯åˆæ¬¡æ‰§è¡Œï¼Œæ‰€ä»¥`updateQueue.shared.pending`ä¸º`null`ï¼Œæ‰§è¡Œåç”Ÿæˆå¦‚ä¸‹ç»“æ„
![alt text](image-3.png)

ç„¶åæ‰§è¡Œè°ƒåº¦æ–¹æ³•è¿›è¡Œè°ƒåº¦`scheduleUpdateOnFiber`

## `scheduleUpdateOnFiber`

åœ¨è¯¥å‡½æ•°ä¸­æœ€é‡è¦çš„å°±æ˜¯`renderRoot`å‡½æ•°

```ts
function renderRoot(
  root: FiberRootNode,
  lanes: Lanes,
  shouldTimeSlice: boolean
) {
  // åˆå§‹åŒ–æ“ä½œ
  prepareFreshStack(root, lanes);

  // renderé˜¶æ®µå…·ä½“æ“ä½œ
  do {
    try {
      workLoop();
      break;
    } catch (e) {
      console.error("workLoopå‘ç”Ÿé”™è¯¯", e);
      workInProgress = null;
    }
  } while (true);

  return;
}
```

å…¶ä¸­`prepareFreshStack`å‡½æ•°

```ts
function prepareFreshStack(root: FiberRootNode, lanes: Lanes) {
  if (__LOG__) {
    console.log("renderé˜¶æ®µåˆå§‹åŒ–å·¥ä½œ", root);
  }
  workInProgress = createWorkInProgress(root.current, {});
  workInProgressRootRenderLane = lanes;
}
```

`workInProgress = createWorkInProgress(root.current, {});`è¯¥è¡Œä»£ç ä»¥`hostRootFiber`èŠ‚ç‚¹çš„`key`ä»¥åŠ`tag`å€¼åˆ›å»ºäº†ä¸€ä¸ªå…¨æ–°çš„`FiberNode`èŠ‚ç‚¹ï¼Œå‘½åä¸º`workInProgress`å˜é‡ï¼Œè¯¥å˜é‡éå¸¸é‡è¦ï¼Œä¿å­˜ç€å½“å‰æ­£åœ¨å¤„ç†çš„èŠ‚ç‚¹çš„å¼•ç”¨ï¼Œè¯¥å€¼æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ã€‚æ‰§è¡Œå®Œæˆåå†…å­˜æ¨¡å‹ä¸ºä¸‹é¢ç¬¬äºŒé˜¶æ®µï¼š
![alt text](image-5.png)

ä¸‹é¢è¿›å…¥æ¸²æŸ“è¿‡ç¨‹ï¼Œæ¸²æŸ“è¿‡ç¨‹ä¸»è¦åˆ†ä¸¤ä¸ªé˜¶æ®µï¼Œä¸€ä¸ªæ˜¯æŒ‰ç…§æ·±åº¦ä¼˜å…ˆé€å±‚å‘ä¸‹åˆ›å»º`FiberNode`æˆ–è€…è¿›è¡Œ`Diff`çš„è¿‡ç¨‹ï¼Œä¸€ä¸ªæ˜¯å‘ä¸Šçš„è¿‡ç¨‹åˆ›å»º`DOM`

## workLoop

æ‰§è¡Œå®Œä¸Šé¢åä¼šè¿›å…¥ä¸€ä¸ª`do...while`å¾ªç¯ï¼Œä¸€ç›´å¾ªç¯æ‰§è¡Œ`workLoop`å‡½æ•°ï¼Œé‚£ä¹ˆ`workLoop`ä¸»è¦æ˜¯åšä»€ä¹ˆçš„å‘¢

```ts
function workLoop() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}
```

åœ¨`workLoop`ä¸­é¦–å…ˆåˆ¤æ–­äº†å½“å‰çš„`workInProgree`æ˜¯å¦å­˜åœ¨ï¼Œå­˜åœ¨åˆ™ç»§ç»­æ‰§è¡Œ`performUnitOfWork`å‡½æ•°

```ts
function performUnitOfWork(fiber: FiberNode) {
  // è·å–å­èŠ‚ç‚¹
  const next = beginWork(fiber, workInProgressRootRenderLane);
  // æ‰§è¡Œå®ŒbeginWorkåï¼ŒpendingProps å˜ä¸º memoizedProps
  fiber.memoizedProps = fiber.pendingProps;
  if (next === null) {
    // å­èŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™æ‰§è¡Œå½’çš„é€»è¾‘
    completeUnitOfWork(fiber);
  } else {
    // å­èŠ‚ç‚¹å­˜åœ¨ï¼Œåˆ™ç»§ç»­workLoop
    workInProgress = next;
  }
}
```

è¿›å…¥å‡½æ•°åé¦–å…ˆä¼šæŒ‡å‘`beginWork`å‡½æ•°ï¼Œåœ¨`beginWork`å‡½æ•°ä¸­ï¼Œä¼šæ ¹æ®`tag`ç±»å‹æ¥è¿›è¡Œä¸åŒçš„å‡½æ•°æ‰§è¡Œï¼Œå¦‚é¦–æ¬¡è¿›å…¥æ—¶`tag`çš„å€¼ä¸º`3`ï¼Œé¦–å…ˆä¼šæ‰§è¡Œ`updateHostRoot`å‡½æ•°

```ts
function updateHostRoot(workInProgress: FiberNode, renderLanes: Lanes) {
  const baseState = workInProgress.memoizedState;
  const updateQueue = workInProgress.updateQueue as UpdateQueue<Element>;
  const pending = updateQueue.shared.pending;
  updateQueue.shared.pending = null;
  // æ¶ˆè´¹updateQueue.shared.pendingä¸­çš„ä»»åŠ¡ï¼Œè¿”å›ä¸€ä¸ª{ memoizedState }å¯¹è±¡
  // memoizedStateçš„å€¼ä¸ºReactElementå¯¹è±¡ï¼Œå½“å‰å°±ä¸º Symbol(react.element)
  const { memoizedState } = processUpdateQueue(baseState, pending, renderLanes);
  workInProgress.memoizedState = memoizedState;
  const nextChildren = workInProgress.memoizedState;
  reconcileChildren(workInProgress, nextChildren);
  return workInProgress.child;
}

export const processUpdateQueue = <State>(
  baseState: State,
  pendingUpdate: Update<State> | null,
  renderLanes: Lanes
): {
  memoizedState: State;
  skippedUpdateLanes: Lanes;
  baseState: State;
  baseQueue: null | Update<State>;
} => {
  const result: ReturnType<typeof processUpdateQueue<State>> = {
    memoizedState: baseState,
  };

  if (pendingUpdate !== null) {
    const action = pendingUpdate.action;
    if (action instanceof Function) {
      result.memoizedState = action(baseState);
    } else {
      result.memoizedState = action;
    }
  }
  return result;
};
```

åœ¨æœªæ‰§è¡Œ`reconcileChildren`ä¹‹å‰ï¼Œå†…å­˜ä¸­çš„æ•°æ®æ¨¡å‹å¦‚ä¸‹ï¼š
![alt text](image-6.png)

## reconcileChildren
