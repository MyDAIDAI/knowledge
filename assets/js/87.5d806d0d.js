(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{448:function(e,t,s){"use strict";s.r(t);var c=s(27),n=Object(c.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"useeffect"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[e._v("#")]),e._v(" useEffect")]),e._v(" "),t("blockquote",[t("blockquote",[t("p",[e._v("useEffect is a React Hook that lets you synchronize a component with an external system.")])])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Reference")]),e._v("： "),t("code",[e._v("useEffect(setup, dependencies?)")])])]),e._v(" "),t("p",[t("strong",[e._v("核心要点")]),e._v("：")]),e._v(" "),t("ul",[t("li",[e._v("setup函数：这是useEffect的第一个参数，即包含副作用逻辑的函数。它可以可选地返回一个清理函数（cleanup function）。")]),e._v(" "),t("li",[e._v("执行时机：\n"),t("ul",[t("li",[e._v("当组件提交（commit）到DOM后，React会运行setup函数。")]),e._v(" "),t("li",[e._v("在每次依赖项发生变化并提交后，React会先运行清理函数（如果提供了），然后再运行setup函数。")]),e._v(" "),t("li",[e._v("当组件从DOM中移除时，React会运行清理函数。")])])])]),e._v(" "),t("p",[t("strong",[e._v("详细解释")]),e._v("：")]),e._v(" "),t("ol",[t("li",[e._v("组件提交（commit）时运行setup函数\n在React中，组件的生命周期包括渲染（render）和提交（commit）阶段。提交阶段是指React将渲染好的虚拟DOM更新到实际DOM的过程。\n当组件首次渲染（mount）和每次更新（update）时，在提交到DOM后，React会运行useEffect中的setup函数。")]),e._v(" "),t("li",[e._v("依赖项变化时的行为\nuseEffect可以接受一个依赖项数组作为第二个参数。当依赖项发生变化时，useEffect会重新执行。\n具体过程：在每次提交（commit）并且依赖项发生变化时，React会先执行清理函数（如果存在），然后再执行setup函数。\n清理函数会使用旧的依赖值执行，而setup函数会使用新的依赖值执行。这确保了清理函数可以清理上一次副作用留下的资源，避免内存泄漏。")]),e._v(" "),t("li",[e._v("组件卸载时的行为\n当组件从DOM中移除（卸载）时，React会执行清理函数。这是为了确保在组件销毁时，清理所有副作用（如订阅、定时器等）。")])])])}),[],!1,null,null,null);t.default=n.exports}}]);