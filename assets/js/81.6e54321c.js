(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{443:function(t,v,_){"use strict";_.r(v);var e=_(27),s=Object(e.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"异步式io与事件式编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步式io与事件式编程"}},[t._v("#")]),t._v(" 异步式IO与事件式编程")]),t._v(" "),v("p",[v("code",[t._v("Node.js")]),t._v("最大的特点就是异步式"),v("code",[t._v("I/O")]),t._v("与事件紧密结合的编程模式")]),t._v(" "),v("h2",{attrs:{id:"阻塞与线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#阻塞与线程"}},[t._v("#")]),t._v(" 阻塞与线程")]),t._v(" "),v("p",[t._v("什么是阻塞? 线程在执行中遇到磁盘读写或者网络通信时（统称为"),v("code",[t._v("I/O")]),t._v("操作），通常要耗费较长时间，这是操作系统会剥夺这个线程的"),v("code",[t._v("CPU")]),t._v("控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为"),v("strong",[t._v("阻塞")]),t._v(".")]),t._v(" "),v("p",[t._v("当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对"),v("code",[t._v("CPU")]),t._v("的控制权，使其继续执行。这种模式为通常执行的同步式"),v("code",[t._v("I/O")]),t._v("或者阻塞式"),v("code",[t._v("I/O")])]),t._v(" "),v("p",[t._v("异步式I/O或非阻塞式I/O则针对所有的I/O操作不采取阻塞的策略。当线程遇到I/O操作时，不会以阻塞的方式等待I/O操作的完成或者数据的返回，而只是将I/O请求发送给操作系统，继续执行下一条语句。当操作系统完成I/O操作时，以事件的形式通知执行I/O操作的线程，线程会在特定时间处理这个事件。为了处理异步I/O，则必须有事件循环")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("多线程同步式"),v("code",[t._v("I/O")]),t._v(" "),v("img",{attrs:{src:"image.png",alt:"alt text"}})])]),t._v(" "),v("li",[v("p",[t._v("单线程异步式"),v("code",[t._v("I/O")]),t._v(" "),v("img",{attrs:{src:"image-1.png",alt:"alt text"}})])])]),t._v(" "),v("p",[v("strong",[t._v("单线程异步式")]),t._v("相对于"),v("strong",[t._v("多线程同步式")]),t._v("的优点：少了多线程的开销")]),t._v(" "),v("p",[t._v("对于操作系统来说，创建一个线程的代价是十分昂贵的，需要给它进行内存分配，列入调度，同时在线程切换的时候需要执行内存换页，CPU的缓存被清空，切换回来的时候需要重新从内存中读取信息，破坏了数据的局部性。")])])}),[],!1,null,null,null);v.default=s.exports}}]);